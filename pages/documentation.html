---
layout: default
title: Documentation
author:  "Fernando Andreotti"
priority: 5
---

<section class="bs-docs-section"> 
<h1 id="benchmark-tools">benchmark-tools</h1><br> 
<h3 id="FECGSYN_exp3results">FECGSYN_exp3results</h3><br> 
<b>Call: </b> <code>function FECGSYN_exp3results
</code> <br> 
<br> 
this script extracts  morphological features of NI-FECG signals and makes
<br> 
<h3 id="FECGSYN_benchFQRS_plot">FECGSYN_benchFQRS_plot</h3><br> 
<b>Call: </b> <code>function FECGSYN_benchFQRS_plot()
</code> <br> 
<br> 
This function produces plots for Experiment 2 of Andreotti et al 2016. 
<br> 
<h3 id="FECGSYN_genresults">FECGSYN_genresults</h3><br> 
<b>Call: </b> <code>function FECGSYN_genresults(path_orig,fs,ch,exp3,debug)
</code> <br> 
<br> 
this script generates a series of abdominal mixtures, containing i) a
<br> 
effects, foetal movement etc).
<br> 
Experiment 3 - Morphologycal Analysis
<br> 
<b>Input:</b> 
<br> 
fs:               Sampling frequency
<br> 
exp3:            Boolean, if 0 runs exp2 and 1 exp3
<br> 
<b>Examples:</b> <br> 
<br> 
<h3 id="FECGSYN_benchFQRS">FECGSYN_benchFQRS</h3><br> 
<b>Call: </b> <code>function FECGSYN_benchFQRS(path_orig,fs,ch,exp3)
</code> <br> 
<br> 
this script generates statistics as in Experiment 2 by Andreotti et al 2016,
<br> 
</section>

<h2 id="benchmark-tools/bibs">benchmark-tools/bibs</h2><br> 
<h3 id="FECGSYN_QRSmincompare">FECGSYN_QRSmincompare</h3><br> 
<b>Call: </b> <code>function [fqrs,maxch] = FECGSYN_QRSmincompare(data,fref,fs,varargin)
</code> <br> 
<br> 
<h3 id="qrs_detect">qrs_detect</h3><br> 
QRS detector based on the P&T method. This is an offline implementation
<br> 
<h3 id="FECGSYN_manalysis">FECGSYN_manalysis</h3><br> 
This function calculates morphological features form signals given two
<br> 
This functin makes use of the ECGPUWAVE script (Jane et al 1996) and
<br> 
</section>

<section class="bs-docs-section"> 
<h1 id="data-generation">data-generation</h1><br> 
<h3 id="phase2qrs">phase2qrs</h3><br> 
this function is used for finding the qrs locations using the phase generated 
<br> 
<h3 id="plot3_volume">plot3_volume</h3><br> 
plot volume conductor together with foetuses and mother heart positions 
<br> 
of simulation configuration. The volume conductor is represented by a
<br> 
0.5]). Remember that the hearts are represented as dipoles which position 
<br> 
orientation specified by the rotation matrices (vols.Rf and vols.Rm).
<br> 
inputs
<br> 
      vols.fheart:   foetal heart position in polar coordinates, 
<br> 
                     supporting multiple pregnancies representation)
<br> 
                     (one cell of 3x1 vector)
<br> 
                     (3 x NB_ELECTRODES vector)
<br> 
                     thetaY,thetaZ - in radian)
<br> 
                     thetaY,thetaZ - in radian)
<br> 
<h3 id="traject_generator">traject_generator</h3><br> 
this function is used to generate trajectories within volume conductor. These
<br> 
modelling, e.g. respiration or fetal movements.
<br> 
inputs
<br> 
  pos_i:  initial position for trajectory [1x3 number array]
<br> 
<h3 id="generate_ecg_mixture">generate_ecg_mixture</h3><br> 
  generate_ecg_mixture(debug,SNRfm,SNRmn,mqrs,fqrs,fs,varargin)
<br> 
<h3 id="generate_hrv">generate_hrv</h3><br> 
generate variable heart rate (HR). Add suddent change of HR 
<br> 
to model high HR variation to test the robustness of a NI-FECG 
<br> 
HR variability (HRV).
<br> 
<b>Input:</b> 
<br> 
      - strhrv.hr:        mean heart rate [bpm]
<br> 
                          hf->simulates respiratory sinus arrythmia
<br> 
      - strhrv.hrstd:     standard deviation of heart rate [bpm]
<br> 
      - strhrv.flhi:      center freqency of high frequency Gaussian (RSA) [Hz]
<br> 
                          (negative) [bpm]
<br> 
                          'mexhat'
<br> 
      - strhrv.accstd     standard deviation (case necessary) 
<br> 
  fs:                     sampling frequency    
<br> 
<h3 id="clean_compress">clean_compress</h3><br> 
this function eliminates some of the substructures from "out" and
<br> 
<h3 id="generate_breathing">generate_breathing</h3><br> 
variable sawtooth shape for modelling respiration. The intention is to
<br> 
of the cardiac dipole with breathing.
<br> 
reference: http://mathworld.wolfram.com/FourierSeriesSawtoothWave.html
<br> 
sawtooth function are kept to make the bwa smooth.
<br> 
<b>Input:</b> 
<br> 
  N:      number of datapoints
<br> 
  debug:  [bool]
<br> 
<b>Output:</b> 
<br> 
<h3 id="add_cardiacdipole">add_cardiacdipole</h3><br> 
  theta,w,fres,R0,epos,traj,debug)
<br> 
dipole equation. This function generates the vectocardiogram (VCG) of 
<br> 
projection of the VCG onto the electrode locations as specified by (elec.ep). 
<br> 
are modelled. Rotation of the heart is modelled by dynamically updating 
<br> 
heart is modelled by updating the dower-like projection matrix H. These
<br> 
the FECG signal. The function returns the VCG signal, the projection
<br> 
case the foetus is moving).
<br> 
       N:     signal length [number of points]
<br> 
      gp_all: Gaussian parameters [cell of cells]
<br> 
              gp{i}{1}:  structure contaning the phase of Gaussian functions used for
<br> 
                  dipole
<br> 
                  modeling the x, y, and z coordinates of the cardiac dipole
<br> 
                  modeling the x, y, and z coordinates of the cardiac dipole
<br> 
<h3 id="load_gparam">load_gparam</h3><br> 
load Gaussian paramters for vcg modelling. The parameters are derived 
<br> 
20sec of the corresponding records. 
<br> 
<h3 id="run_ecg_generator">run_ecg_generator</h3><br> 
generate a realistic FECG-MECG mixture. The physiological phenomenon that
<br> 
rotation of the heart axis with respect to breathing rate, translation
<br> 
Note that in order to make repeated simulation more variable (and so more
<br> 
hearts are randomly placed around the default coordinates. Note that the
<br> 
the volume conductor). As a consequence, electodes location, hearts
<br> 
<h3 id="add_noisedipole">add_noisedipole</h3><br> 
this function is used to generate realistic noise. The MA, EM and BW
<br> 
three main limitations when using these records; 1. their length is
<br> 
of them when generating multiple noise segments), 
<br> 
noise on the VCG then we need three) and 3. this is noise from one
<br> 
In order to tackle these problems we propose to use an AR model
<br> 
as the output of an all-pole infinite impulse response filter with input 
<br> 
of one of the NSTDB signals. This defines filter coefficients with 
<br> 
of the records available in the NSTDB and integrate some variability, the 
<br> 
unsuring they stay in the unit cicle.
<br> 
<b>Input:</b> 
<br> 
  ntype:  type of noise to generate (MA,EM or BW) [string]
<br> 
  debug:  debug mode level [integer]
<br> 
<b>Output:</b> 
<br> 
       dmodel.H      - Dower-like matrix for dipole (assuming time invariance)
<br> 
       dmodel.type   - always 3 (noise dipole)
<br> 
                            sin(linspace(-pi,pi,N)
<br> 
Change log:
<br> 
improvements to the AR model should allow faster generation
<br> 
</section>

<section class="bs-docs-section"> 
<h1 id="extraction-methods">extraction-methods</h1><br> 
<h3 id="FECGSYN_kf_extraction">FECGSYN_kf_extraction</h3><br> 
MECG cancellation algorithms using the Extended Kalman Filter/Smoother.
<br> 
by Dr. Reza Sameni and and also in (Andreotti 2014)
<br> 
Inputs
<br> 
              position of a MQRS
<br> 
  varargin (in this order):
<br> 
      fs:         sampling frequency (NOTE: this code is meant to work at 1kHz)
<br> 
                  the offline smoothing (EKS) 
<br> 
  residual:   residual containing the FECG
<br> 
<h3 id="FECGSYN_adaptfilt_extraction">FECGSYN_adaptfilt_extraction</h3><br> 
MECG cancellation algorithms using a adaptive filtring methods.
<br> 
              Least Mean Square (LMS)
<br> 
              Echo State Neural Network (ESN)
<br> 
  peaks:      MQRS markers in ms. Each marker corresponds to the
<br> 
  ecg:        matrix of abdominal ecg channels
<br> 
  method:     method to use (LMS,RLS,ESN)
<br> 
<h3 id="main_extract_data">main_extract_data</h3><br> 
<b>Call: </b> <code>function main_extract_data(path,narrowband,wfdb)
</code> <br> 
<br> 
<h3 id="FECGSYN_ts_extraction">FECGSYN_ts_extraction</h3><br> 
Template subtraction for MECG cancellation. Five template subtraction techniques 
<br> 
technique is required then an the EKF technique as in (Sameni 2007) is recommended.
<br> 
inputs
<br> 
              position of a MQRS
<br> 
  method:     method to use ('TS','TS-CERUTTI','TS-SUZANNA','TS-LP','TS-PCA')
<br> 
<h3 id="FECGSYN_bss_extraction">FECGSYN_bss_extraction</h3><br> 
Uses Blind Source Separation Methods for FECG extraction given a
<br> 
terms of F1-measure, is picked as best channel.
<br> 
Available methods:
<br> 
Principal Component Analysis (PCA)
<br> 
Input
<br> 
method:    String containing method name i.e. 'ICA' or 'PCA'
<br> 
blen:      Divide signal into segment of blen length
<br> 
refqrs:    Array containing reference QRS detections for F1 measure
<br> 
blen:      Iterates method every blen (in seconds)
<br> 
</section>

<section class="bs-docs-section"> 
<h1 id="utils">utils</h1><br> 
<h3 id="FECGSYN_plotmix">FECGSYN_plotmix</h3><br> 
<b>Call: </b> <code>Function to plot generated mixtures
</code> <br> 
<br> 
This functin plots Nplots channels from fecgsyn's internal struct "out".
<br> 
<h3 id="wfdb2fecgsyn">wfdb2fecgsyn</h3><br> 
<b>Call: </b> <code>function out = wfdb2fecgsyn(path)
</code> <br> 
<br> 
<h3 id="Bxb_compare">Bxb_compare</h3><br> 
This function is similar to the function bxb.exe from Physionet's
<br> 
match the reference. The algorithm is based on the entry by Joachim Behar 
<br> 
EC57 Norm 1998
<br> 
Input
<br> 
testqrs:       detections to be tested against 
<br> 
<h3 id="fecgsyn2wfdb">fecgsyn2wfdb</h3><br> 
<b>Call: </b> <code>function fecgsyn2wfdb(argument)
</code> <br> 
<br> 
</section>
  I might use this for input/output list:<br>
  <div class="table-responsive">
    <table class="table table-bordered table-striped">
      <thead>
        <tr>
          <th style="width: 130px;">Name</th>
          <th>description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>githubButton</td>
          <td>Data used to generate <a href="http://ghbtns.com/">GitHub Buttons</a>. Provide <code>user</code> and <code>repo</code></td>
        </tr>
        <tr>
          <td>twitter.enabled</td>
          <td>Enable or disable Twitter "Tweet" button</td>
        </tr>
        <tr>
          <td>twitter.via</td>
          <td>Account linked to "Tweet" button</td>
        </tr>
        <tr>
          <td>twitter.hash</td>
          <td>Default hashtags for the "Tweet" button</td>
        </tr>
        <tr>
          <td>twitter.account</td>
          <td>Account for Twitter "Follow" button. Leave empty to deactivate</td>
        </tr>
        <tr>
          <td>facebook.enabled</td>
          <td>Enable or disable Facebook "Like" &amp; "Share" buttons</td>
        </tr>
        <tr>
          <td>facebook.profileUrl</td>
          <td>Profile for Facebook "Follow" button. Leave empty to deactivate</td>
        </tr>
      </tbody>
    </table>
  </div>
